# sudo がなぜホスト名を参照するのか？

`hostnamectl` でホスト名前を変えたら `sudo` にかなりの時間がかかるようになってしまった。  
`/etc/hosts` を更新することで直るのはわかるのだが、`sudo` とホスト名の関係がわからなかった。

以下の理由らしい。  
[https://superuser.com/questions/429790/sudo-command-trying-to-search-for-hostname](https://superuser.com/questions/429790/sudo-command-trying-to-search-for-hostname)

ChatGPT による翻訳。
> /etc/sudoersファイルは複数のサーバー間で配布できるように設計されています。これを実現するために、ファイル内の各権限にはホスト部分があります。  
> 通常、これはALL=に設定されており、これは権限がどのサーバーでも有効であることを意味しますが、特定のホストに設定することもできます。  
> ```
> %sudo    kaagini=(ALL) ALL
> ```  
> このルールが適用されるべきかどうかをsudoが知るためには、実行されているホストを調査する必要があります。これには/etc/hostsが正しいことを前提とした呼び出しが使われています。そのため、これが正しくない場合には失敗します。
> もし権限のホスト部分が全ての権限に対してALL=に設定されている場合、sudoは名前の検索をする必要がないと主張されるかもしれませんが、それはうまく機能しません。sudoはルールを処理する前に実行されている場所を把握するようです。  
> これは実際にはsudoが現在のマシンでユーザーが何ができるかを確認するためのもので、管理者としては、100台のサーバーがあれば、それぞれのマシンごとに異なる/etc/sudoersファイルを維持する必要があります。sudoersは権限にホスト部分を持っているので、1つのsudoersファイルを維持し、それをすべてのマシンに配布することができ、それでも各マシンでユーザーが何ができるかについて詳細な制御が可能です。

# Dev Containers に感動した
VSCode に乗り換えてから日が浅い & キャッチアップしていないので全く知らなかった。

今まで特殊な環境で作業したい場合は docker で image を作成後、  
```sh
$ docker run -v ./share:/mnt/host --name=$NAME -ti $NAME
```
のようなコマンドでコンテナ起動し、`./share` にコンテナ内で使用したいファイルを配置していた。  

この方式には
* ホストの環境を汚さずに済む
* 間違って開発環境の構成を壊してしまってもすぐ復旧できる
* ソースコードはホストに保存されるのでコンテナを削除しても成果は消えない

といったメリットを感じつつも
* 一々ファイル群を `./share` へ配置しなくてはならない  
* コード補完などが一切効かない(補完はあまり当てにしていないが、ジャンプがしづらいのが嫌)  
* ビルドのためにコンテナに一々アタッチしないといけない 
* 何か権限関連でエラーが出る(昔のことなので覚えていない)  

といった不満を常に抱えていた。  
Dev Containers は上記の不満を解決してくれつつ、
ウィザードに沿って設定してボタン一つで開発できる状態にしてくれるのには感動した。

低スペックマシンでコーディングして高スペックマシンでビルドしたい場合は、
高スペックマシンに SSH で接続して Dev Containers を使うしかなさそうかな。

git のホスティングサービスとして GitHub を利用する開発であれば、GitHub Coodespaces で出来たりするんだろうか。
